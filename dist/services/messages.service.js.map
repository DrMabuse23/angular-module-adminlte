{"version":3,"sources":["../../src/services/messages.service.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,UAAA,EAAW,MAAO,eAAA,CAAgB;AAC3C,OAAO,EAAc,OAAA,EAAS,aAAA,EAAc,MAAO,SAAA,CAAU;AAE7D,IAAM,eAAA,GAA6B,EAAA,CAAG;AAKtC;IAeE,8DAA8D;IAE9D;QAAA,iBAgBC;QAhCO,iBAAY,GAAc,EAAE,CAAC;QACrC,iDAAiD;QAC1C,gBAAW,GAAqB,IAAI,OAAO,EAAW,CAAC;QAE9D,6EAA6E;QACtE,aAAQ,GAA6B,IAAI,aAAa,CAAY,CAAC,CAAC,CAAC;QAE5E,kEAAkE;QAClE,0EAA0E;QAC1E,wBAAwB;QACjB,YAAO,GAAiB,IAAI,OAAO,EAAO,CAAC;QAElD,iBAAiB;QACV,WAAM,GAAqB,IAAI,OAAO,EAAW,CAAC;QAIvD,gGAAgG;QAChG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAC,GAAG;YACzB,KAAI,CAAC,YAAY,GAAG,GAAG,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC;YAC3C,OAAO,CAAC,GAAG,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC;YAC/B,KAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAI,CAAC,YAAY,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW;aACb,GAAG,CAAC,UAAS,OAAgB;YAC5B,MAAM,CAAC,UAAC,QAAmB;gBACzB,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;YAClC,CAAC,CAAC;QACJ,CAAC,CAAC;aACD,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAE7B,CAAC;IAED,oDAAoD;IAC7C,oCAAU,GAAjB,UAAkB,OAAgB;QAChC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACjC,CAAC;IAEI,0BAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,UAAU,EAAE;KACnB,CAAC;IACF,kBAAkB;IACX,8BAAc,GAAmE,cAAM,OAAA,EAC7F,EAD6F,CAC7F,CAAC;IACF,sBAAC;CA9CD,AA8CC,IAAA;SA9CY,eAAe","file":"messages.service.js","sourceRoot":"","sourcesContent":["// based on https://github.com/ng-book/angular2-rxjs-chat/blob/master/app/ts/services/MessagesService.ts\r\nimport { User } from '../models/user';\r\nimport { Message } from '../models/message';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, Subject, ReplaySubject } from 'rxjs/Rx';\r\n\r\nconst initialMessages: Message[] = [];\r\n\r\ntype IMessagesOperation = (messages: Message[]) => Message[];\r\n\r\n\r\nexport class MessagesService {\r\n  private messagesList: Message[] = [];\r\n  // a stream that publishes new messages only once\r\n  public newMessages: Subject<Message> = new Subject<Message>();\r\n\r\n  // `messages` is a stream that emits an array of the most up to date messages\r\n  public messages: ReplaySubject<Message[]> = new ReplaySubject<Message[]>(1);\r\n\r\n  // `updates` receives _operations_ to be applied to our `messages`\r\n  // it's a way we can perform changes on *all* messages (that are currently\r\n  // stored in `messages`)\r\n  public updates: Subject<any> = new Subject<any>();\r\n\r\n  // action streams\r\n  public create: Subject<Message> = new Subject<Message>();\r\n  // public markThreadAsRead: Subject<any> = new Subject<any>();\r\n\r\n  constructor() {\r\n    // recois des operation, et les fais sur la liste interne, puis diffuse le resultat sur messages\r\n    this.updates.subscribe((ope) => {\r\n      this.messagesList = ope(this.messagesList);\r\n      console.log(this.messagesList);\r\n      this.messages.next(this.messagesList);\r\n    });\r\n\r\n    this.newMessages\r\n      .map(function(message: Message): IMessagesOperation {\r\n        return (messages: Message[]) => {\r\n          return messages.concat(message);\r\n        };\r\n      })\r\n      .subscribe(this.updates);\r\n\r\n  }\r\n\r\n  // an imperative function call to this action stream\r\n  public addMessage(message: Message): void {\r\n    this.newMessages.next(message);\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}