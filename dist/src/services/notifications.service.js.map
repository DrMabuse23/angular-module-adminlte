{"version":3,"sources":["../../../src/services/notifications.service.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,UAAA,EAAW,MAAO,eAAA,CAAgB;AAC3C,OAAO,EAAc,OAAA,EAAS,aAAA,EAAc,MAAO,SAAA,CAAU;AAE7D,IAAM,oBAAA,GAAuC,EAAA,CAAG;AAKhD;IAeE,8DAA8D;IAE9D;QAAA,iBAgBC;QAhCO,sBAAiB,GAAmB,EAAE,CAAC;QAC/C,sDAAsD;QAC/C,qBAAgB,GAA0B,IAAI,OAAO,EAAgB,CAAC;QAE7E,uFAAuF;QAChF,kBAAa,GAAkC,IAAI,aAAa,CAAiB,CAAC,CAAC,CAAC;QAE3F,uEAAuE;QACvE,+EAA+E;QAC/E,6BAA6B;QACtB,YAAO,GAAiB,IAAI,OAAO,EAAO,CAAC;QAElD,iBAAiB;QACV,WAAM,GAA0B,IAAI,OAAO,EAAgB,CAAC;QAIjE,qGAAqG;QACrG,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAC,GAAG;YACzB,KAAI,CAAC,iBAAiB,GAAG,GAAG,CAAC,KAAI,CAAC,iBAAiB,CAAC,CAAC;YACrD,OAAO,CAAC,GAAG,CAAC,KAAI,CAAC,iBAAiB,CAAC,CAAC;YACpC,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAI,CAAC,iBAAiB,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,gBAAgB;aAClB,GAAG,CAAC,UAAS,YAA0B;YACtC,MAAM,CAAC,UAAC,aAA6B;gBACnC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YAC5C,CAAC,CAAC;QACJ,CAAC,CAAC;aACD,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IAE7B,CAAC;IAED,oDAAoD;IAC7C,8CAAe,GAAtB,UAAuB,YAA0B;QAC/C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC3C,CAAC;IAEI,+BAAU,GAA0B;QAC3C,EAAE,IAAI,EAAE,UAAU,EAAE;KACnB,CAAC;IACF,kBAAkB;IACX,mCAAc,GAAmE,cAAM,OAAA,EAC7F,EAD6F,CAC7F,CAAC;IACF,2BAAC;CA9CD,AA8CC,IAAA;SA9CY,oBAAoB","file":"notifications.service.js","sourceRoot":"","sourcesContent":["\r\n// based on https://github.com/ng-book/angular2-rxjs-chat/blob/master/app/ts/services/NotificationsService.ts\r\nimport { Notification } from '../models/notification';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, Subject, ReplaySubject } from 'rxjs/Rx';\r\n\r\nconst initialNotifications: Notification[] = [];\r\n\r\ntype INotificationsOperation = (notifications: Notification[]) => Notification[];\r\n\r\n\r\nexport class NotificationsService {\r\n  private notificationsList: Notification[] = [];\r\n  // a stream that publishes new notifications only once\r\n  public newNotifications: Subject<Notification> = new Subject<Notification>();\r\n\r\n  // `notifications` is a stream that emits an array of the most up to date notifications\r\n  public notifications: ReplaySubject<Notification[]> = new ReplaySubject<Notification[]>(1);\r\n\r\n  // `updates` receives _operations_ to be applied to our `notifications`\r\n  // it's a way we can perform changes on *all* notifications (that are currently\r\n  // stored in `notifications`)\r\n  public updates: Subject<any> = new Subject<any>();\r\n\r\n  // action streams\r\n  public create: Subject<Notification> = new Subject<Notification>();\r\n  // public markThreadAsRead: Subject<any> = new Subject<any>();\r\n\r\n  constructor() {\r\n    // recois des operation, et les fais sur la liste interne, puis diffuse le resultat sur notifications\r\n    this.updates.subscribe((ope) => {\r\n      this.notificationsList = ope(this.notificationsList);\r\n      console.log(this.notificationsList);\r\n      this.notifications.next(this.notificationsList);\r\n    });\r\n\r\n    this.newNotifications\r\n      .map(function(notification: Notification): INotificationsOperation {\r\n        return (notifications: Notification[]) => {\r\n          return notifications.concat(notification);\r\n        };\r\n      })\r\n      .subscribe(this.updates);\r\n\r\n  }\r\n\r\n  // an imperative function call to this action stream\r\n  public addNotification(notification: Notification): void {\r\n    this.newNotifications.next(notification);\r\n  }\r\n\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}